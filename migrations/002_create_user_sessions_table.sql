-- Migration: Create user_sessions table for comprehensive session tracking
-- This table will track user sessions across web and iOS platforms

-- Create user_sessions table
CREATE TABLE IF NOT EXISTS user_sessions (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  
  -- User reference
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  
  -- Session identification
  session_id TEXT NOT NULL UNIQUE, -- Unique session identifier (generated by client)
  platform TEXT NOT NULL CHECK (platform IN ('web', 'ios-external', 'ios-internal', 'ios-widget', 'macos-internal')),
  
  -- Session timing
  started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  last_activity_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ended_at TIMESTAMPTZ NULL, -- NULL for active sessions
  
  -- Session metadata
  device_info JSONB NOT NULL DEFAULT '{}', -- Device information (OS, version, etc.)
  location_info JSONB DEFAULT '{}', -- Location data (country, timezone, etc.)
  user_agent TEXT, -- Browser user agent (web only)
  ip_address INET, -- Client IP address (masked for privacy)
  
  -- Session metrics
  total_duration_seconds INTEGER DEFAULT 0, -- Total session duration in seconds
  activity_count INTEGER DEFAULT 0, -- Number of activities during session
  last_heartbeat_at TIMESTAMPTZ DEFAULT NOW(), -- Last heartbeat received
  
  -- Session status
  status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'idle', 'ended', 'timeout')),
  end_reason TEXT CHECK (end_reason IN ('logout', 'timeout', 'manual', 'app_close', 'crash')),
  
  -- Audit fields
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_user_sessions_user_id ON user_sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_user_sessions_session_id ON user_sessions(session_id);
CREATE INDEX IF NOT EXISTS idx_user_sessions_platform ON user_sessions(platform);
CREATE INDEX IF NOT EXISTS idx_user_sessions_status ON user_sessions(status);
CREATE INDEX IF NOT EXISTS idx_user_sessions_started_at ON user_sessions(started_at);
CREATE INDEX IF NOT EXISTS idx_user_sessions_last_activity ON user_sessions(last_activity_at);
CREATE INDEX IF NOT EXISTS idx_user_sessions_active ON user_sessions(user_id, status) WHERE status = 'active';

-- Enable Row Level Security (RLS)
ALTER TABLE user_sessions ENABLE ROW LEVEL SECURITY;

-- RLS Policies
-- Users can view their own sessions
CREATE POLICY "Users can view their own sessions" ON user_sessions
  FOR SELECT USING (
    auth.uid() = user_id 
    OR auth.role() = 'service_role'
  );

-- Users can create their own sessions
CREATE POLICY "Users can create their own sessions" ON user_sessions
  FOR INSERT WITH CHECK (
    auth.uid() = user_id 
    OR auth.role() = 'service_role'
  );

-- Users can update their own sessions
CREATE POLICY "Users can update their own sessions" ON user_sessions
  FOR UPDATE USING (
    auth.uid() = user_id 
    OR auth.role() = 'service_role'
  );

-- Service role can manage all sessions (for cleanup and analytics)
CREATE POLICY "Service role can manage all sessions" ON user_sessions
  FOR ALL USING (auth.role() = 'service_role');

-- Create function to automatically update updated_at timestamp
CREATE OR REPLACE FUNCTION update_user_sessions_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ language 'plpgsql';

-- Create trigger to automatically update updated_at
CREATE TRIGGER update_user_sessions_updated_at 
  BEFORE UPDATE ON user_sessions 
  FOR EACH ROW EXECUTE FUNCTION update_user_sessions_updated_at_column();

-- Create function to calculate session duration
CREATE OR REPLACE FUNCTION calculate_session_duration(session_start TIMESTAMPTZ, session_end TIMESTAMPTZ DEFAULT NOW())
RETURNS INTEGER AS $$
BEGIN
  RETURN EXTRACT(EPOCH FROM (session_end - session_start))::INTEGER;
END;
$$ language 'plpgsql';

-- Create function to clean up old sessions (for maintenance)
CREATE OR REPLACE FUNCTION cleanup_old_sessions(days_old INTEGER DEFAULT 90)
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM user_sessions 
  WHERE ended_at IS NOT NULL 
    AND ended_at < NOW() - INTERVAL '%d days' % days_old;
  
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$ language 'plpgsql';

-- Create function to end inactive sessions
CREATE OR REPLACE FUNCTION end_inactive_sessions(timeout_minutes INTEGER DEFAULT 60)
RETURNS INTEGER AS $$
DECLARE
  updated_count INTEGER;
BEGIN
  UPDATE user_sessions 
  SET 
    status = 'timeout',
    ended_at = NOW(),
    end_reason = 'timeout',
    total_duration_seconds = calculate_session_duration(started_at, NOW())
  WHERE status = 'active' 
    AND last_heartbeat_at < NOW() - INTERVAL '%d minutes' % timeout_minutes;
  
  GET DIAGNOSTICS updated_count = ROW_COUNT;
  RETURN updated_count;
END;
$$ language 'plpgsql';

-- Create view for active sessions analytics
CREATE OR REPLACE VIEW active_sessions_summary AS
SELECT 
  platform,
  COUNT(*) as active_count,
  AVG(EXTRACT(EPOCH FROM (NOW() - started_at))/60) as avg_session_minutes,
  MIN(started_at) as oldest_session,
  MAX(last_activity_at) as latest_activity
FROM user_sessions 
WHERE status = 'active'
GROUP BY platform;

-- Grant permissions
GRANT SELECT ON active_sessions_summary TO authenticated;
GRANT SELECT ON user_sessions TO authenticated;

-- Comments for documentation
COMMENT ON TABLE user_sessions IS 'Tracks user sessions across web and mobile platforms';
COMMENT ON COLUMN user_sessions.session_id IS 'Unique client-generated session identifier';
COMMENT ON COLUMN user_sessions.platform IS 'Platform: web, ios-external, ios-internal, ios-widget, macos-internal';
COMMENT ON COLUMN user_sessions.device_info IS 'JSON containing device metadata (OS, version, model, etc.)';
COMMENT ON COLUMN user_sessions.location_info IS 'JSON containing location data (country, timezone, etc.)';
COMMENT ON COLUMN user_sessions.total_duration_seconds IS 'Total session duration in seconds';
COMMENT ON COLUMN user_sessions.activity_count IS 'Number of activities/interactions during session';
COMMENT ON COLUMN user_sessions.last_heartbeat_at IS 'Last heartbeat received from client';